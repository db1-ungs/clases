= Mini Guía de MongoDB
Ximena Ebertz <xxx>
v2, {docdate}
:title-page:
:numbered:
:toc-title: Contenidos
:toc: left
:tabsize: 4
:icons: font
:source-highlighter: coderay
:note-caption: Nota
:figure-caption: Figura
:table-caption: Tabla
:pdf-page-size: A4
:pdf-page-margin: [3cm, 3cm, 3cm, 3cm]

[small]#Copyright (C) 2023 Ximena Ebertz. All rights reserved.#

En este documento, presentamos una introducción a la sintaxis de la base de datos documental MongoDB. Para cada ejemplo, presentamos la query _input_ y el _output_ dado por el gestor de base de datos.

Se utilizará el siguiente diagrama de entidad-relación como punto de partida.

image::img/der-alumne-materia.jpg[align=center]

== Diseño

A diferencia de las bases de datos relacionales, para diseñar una base de datos no relacional se necesita más información que únicamente el DER.

En particular, una base de datos documental como MongoDB se puede diseñar en base al DER y a las principales consultas que se realizarán sobre la base de datos. Esto es porque las bases de datos no relacionales están diseñadas para clusterizarse, por lo que la información se encuentra distribuida en distintos nodos de un cluster.

Si la información a obtener para una consulta recurrente no se encuentra en un mismo nodo, las operaciones pueden ralentizarse y la información puede estar desactualizada. Por este motivo, el diseño de colecciones y documentos debe realizarse pensando en los puntos principales para los que se creó la base de datos. De esta forma, obtenemos consultas más rápidas y eficaces.

En este caso, las principales consultas que definimos, a modo de ejemplo, son las siguientes:

1. Obtener los estudiantes que cursan una materia determinada
2. Obtener los estudiantes que desaprobaron algún parcial
3. Materias cursadas por un estudiante en el año 2015
4. Obtener los docentes que dictan una materia
5. Obtener las materias que se dictan en cierto semestre

// ! definir dónde explico el concepto de colección: slide o guía?
El diseño se puede presentar mediante los nombres de las colecciones, y un documento de ejemplo de cada colección. En este caso, podemos tener en cuenta las colecciones `alumnes` y `materias`, con documentos que siguen la siguiente estructura:

.alumne
[source, JSON]
----
{
  "_id": 1,
  "dni": 37627821,
  "nombre": "Anthony",
  "apellido": "Stark",
  "materiaCursada": {
    "id": 5,
    "nombre": "Bases de Datos I",
    "anio": 2024,
    "semestre": 1,
    "parciales": [
      {
        "fecha": { "$date": "2024-05-01T00:00:00Z" },
        "nota": 9
      }
    ]
  }
}
----

.materia
[source, JSON]
----
{
  "_id": 5,
  "cod": "A0524",
  "nombre": "Bases de Datos I",
  "anio": 2024,
  "semestre": 1,
  "docentes": ["Bertaccini, Daniel", "Ebertz, Ximena", "Rondelli, Hernán"],
  "parciales": [
    {
      "fecha": { "$date": "2024-05-01T00:00:00Z" },
      "descripcion": "Parcial"
    }
  ]
}
----

Se puede ver que, en este caso, se tiene el el documento del alumne el código de la materia cursada y su nombre. El código es el campo `_id` del documento de la materia, por lo que el programador debe mantener la coherencia del campo `id` cuando inserta nuevos alumnes. Este tipo de referencia se denomina *referencia manual*, y es la manera más sencilla de referenciar.

Por otra parte, podemos ver que cada alumno tiene la información de una materia cursada. Por lo que, en la colección `alumnos`, existirá un documento por cada materia del alumno.

Almacenar el nombre de la materia en el documento del alumno es una decisión de diseño. No es necesario, ya que con el código se puede obtener, pero es mejor aprovechar la redundancia y la desnormalización, para que las consultas finales sean lo más sencillas posibles.

Por otra parte, en la colección `materias` también existe redundancia, ya que habrá un documento por cada semestre para una materia. De esta forma, se almacena la información de los docentes por semestre, así como la de los parciales. Podría haber un documento por materia y actualizarlo por semestre, pero la información previa se perdería.

== Crear base de datos

La creación de la base de datos se realiza con la instrucción `use nombreDB`. Si existe, MongoDB cambia la base de datos en uso a la base de datos especificada. Si no existe, se crea.

.sintaxis de creación de base de datos
[source, console]
----
xime@test> use cursada
----

Si luego de esto ejecutamos la instrucción `show dbs`, se mostrará la base de datos creadas y las bases de datos por default de MongoDB.

[source, console]
----
xime@cursada> show dbs
cursada       40.00 KiB
test          72.00 KiB
admin        368.00 KiB
local         10.14 GiB
----

// notar prompt: explicar cómo cambiarlo si usamos atlas
// para una sesión: prompt = function () { return "xime@" + db.getName() + "> "; }

== Insertar datos

Existen diversas formas de insertar datos. Un documento se inserta en una colección, concepto similar al de una tabla. Para poder insertar un documento, no es necesario crear la colección. Se puede insertar la información asumiendo que la colección existe. Si no existe, MongoDB la crea.

=== Insertar un documento

Para insertar un único documento, utilizamos la sintaxis `db.coleccion.insertOne({...})`, pasando como parámetro el documento a insertar.

[source, console]
----
xime@cursada> db.alumnes.insertOne({ _id: 8, dni: 40822971, nombre: 'Clint', apellido: 'Barton' })
----

MongoDB es gestor de bases de datos que permite la ejecución de código JavaScript. Por lo que, se puede almacenar información en variables, realizar loops, crear funciones, entre otras cosas. Esto lo podríamos utilizar también para interactuar con la base de datos, por ejemplo, insertando documentos.

[source, console]
----
xime@cursada> var anio = 2024
xime@cursada> for (var i = 0; i < 8; i++) {
... sem = i % 2 + 1
... db.materias.insertOne({ _id: i, cod: "A0524", nombre: "Bases de Datos I", anio: anio, semestre: sem })
... anio = anio + sem - 1
... }
----

En este caso, se utiliza un for para insertar documentos para todos los semestres de la materia "Bases de Datos I" hasta el año 2027, inclusive.

=== Insertar un array de documentos

Para insertar un array de documentos, utilizamos la función `db.coleccion.insertMany({...})`, pasando como parámetro el array a insertar. Este array puede estar en una variable, o se puede escribir directamente. Por ejemplo, si quisiéramos insertar los documentos de los años 2024 y 2025 para la materia "Bases de Datos I", podríamos hacer lo siguiente:

[source, console]
----
xime@cursada> db.materias.insertMany([
... { _id: 1, cod: 'A0524', nombre: 'Bases de Datos I', anio: 2024, semestre: 1 },
... { _id: 2, cod: 'A0524', nombre: 'Bases de Datos I', anio: 2024, semestre: 2 },
... { _id: 3, cod: 'A0524', nombre: 'Bases de Datos I', anio: 2025, semestre: 1 },
... { _id: 4, cod: 'A0524', nombre: 'Bases de Datos I', anio: 2025, semestre: 2 }
... ])
----

=== Insertar un array de documentos desde un archivo externo

==== Local

Para importar datos a una base de datos local, debemos utilizar el comando `mongoimport` desde la terminal de la siguiente manera:

[source, console]
----
xime ~ $ mongoimport -d cursada -c alumnes --file="/home/xime/alumnes.json"
----

Es importante que se realice desde la terminal del sistema, no desde `mongosh`.

Las opciones `-d` y `-c` corresponden al nombre de la base de datos y al nombre de la colección, respectivamente.

==== Atlas

Si quisiéramos insertar un array de documentos desde un archivo externo, debemos almacenar la información de una variable y posteriormente utilizar la función `db.coleccion.insertMany({...})`, pasándole como parámetro la variable con la información.

Se puede leer un archivo desde `mongosh` hosteado en Atlas de la siguiente manera:

.lectura de un archivo
[source, console]
----
xime@cursada> const alumnes = EJSON.parse(fs.readFileSync("alumnes.json"))
----

Luego, insertamos los datos, con la función previamente mencionada

.inserción de datos
[source, console]
----
xime@cursada> db.alumnes.insertMany(alumnes)
----

Luego de insertar los datos, se puede ejecutar la instrucción `show collections` para visualizar las colecciones creadas.

[source, console]
----
xime@cursada> show collections
alumnes
materias
----

== Select

MongoDB no utiliza el lenguaje SQL, por lo que no existe la query `select * from materia;`. Todas las consultas se realizan con la sintaxis `db.coleccion.funcion()`.

=== Find

La alternativa a `select` es la función `find()`, que se puede utilizar de tres maneras distintas:

1. `db.coleccion.find()`: devuelve todos los documentos de la colección especificada.
2. `db.coleccion.find({selección})`: devuelve todos los documentos de la colección que cumplen con el criterio de selección. La selección corresponde al `where` en SQL.
3. `db.coleccion.find({selección}, {proyección})`: devuelve los campos especificados en la proyección de los documentos que cumplen con el criterio de selección. La proyección corresponde a las columnas seleccionadas en SQL.

También, se puede obtener el primer elemento de la colección con la función `findOne()`.

De esta forma, si quisiera ver todas las materias, podría realizar la siguiente consulta:

[source, console]
----
xime@cursada> db.materias.find()
[
  {
    _id: 5,
    cod: 'A0524',
    nombre: 'Bases de Datos I',
    anio: 2024,
    semestre: 1,
    docentes: [ 'Bertaccini, Daniel', 'Ebertz, Ximena', 'Rondelli, Hernán' ],
    parciales: [
      {
        fecha: ISODate("2024-05-01T00:00:00.000Z"),
        descripcion: 'Parcial'
      }
    ]
  },
  {
    _id: 6,
    cod: 'A0532',
    nombre: 'Bases de Datos II',
    anio: 2024,
    semestre: 1,
    docentes: [],
    parciales: [
      {
        fecha: ISODate("2024-04-01T00:00:00.000Z"),
        descripcion: 'Primer Parcial'
      },
      {
        fecha: ISODate("2024-05-01T00:00:00.000Z"),
        descripcion: 'Segundo Parcial'
      },
      {
        fecha: ISODate("2024-06-01T00:00:00.000Z"),
        descripcion: 'Tercer Parcial'
      }
    ]
  },
  ...
]
----

Si quisiera los nombres de las materias que se dan el primer semestre del año 2024, podría realizar la siguiente consulta:

[source, console]
----
xime@cursada> db.materias.find({anio: 2024, semestre: 1}, {_id: 0, nombre: 1})
[
  { nombre: 'Bases de Datos I' },
  { nombre: 'Bases de Datos II' },
  { nombre: 'Programación III' },
  { nombre: 'Introducción a la Programación' },
  { nombre: 'Física Cuántica' }
]
----

Por defecto, siempre se incluye el atributo `_id` en la proyección, aunque no se especifique. Por lo que, para que no se incluya, le asignamos un cero en la proyección. Los atributos que se quieren mostrar, se especifican con un uno.

Esta consulta es equivalente a la query SQL `select nombre from materia where anio = 2024 and semestre = 1;`

Para obtener los docentes de la materia 'Bases de Datos I' del primer semestre 2024, se puede realizar la siguiente consulta:

[source, console]
----
xime@cursada> db.materias.find({nombre: 'Bases de Datos I', anio: 2024, semestre: 1}, {_id: 0, nombre: 1, docentes: 1})
[
  {
    nombre: 'Bases de Datos I',
    docentes: [ 'Bertaccini, Daniel', 'Ebertz, Ximena', 'Rondelli, Hernán' ]
  }
]
----

=== Sort

=== Count

== Update

updateOne
updateMany

$set y $unset

== Comparación

$eq $gt $gte $in $lt $lte $ne $nin

== Operadores lógicos

$and $not $nor $or $exists

== Array

== Set

== Map

== Eliminar datos

=== Eliminar documentos

db.coleccion.remove({selección})

=== Eliminar coleccion

db.coleccion.drop()