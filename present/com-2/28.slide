Transacciones

Hern√°n Rondelli
lucifer.unix.cabj@gmail.com

Daniel Bertaccini
dbertacc@campus.ungs.edu.ar

* rondelli.github.io/db1/com-2/trans.html

.image img/rondelli.github.io-db1-com-2-trans.html.png 500 _

* Transacciones ‚Äì ¬øPara qu√© sirven?

* Transacciones ‚Äì ¬øPara qu√© sirven?

- Acceso concurrente a los datos
- Resistencia a fallas

* Acceso concurrente (1)

*access*‚Üí*read,*modify,*write*

Supongamos dos modificaciones simult√°neas:

Acceso A

 update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;

Acceso B

 update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;

Si el cliente ten√≠a $10000 en su cuenta, ¬øcu√°nto dinero tiene ahora?

* Acceso concurrente (1 - continuaci√≥n)

*access*‚Üí*read,*modify,*write*

El *update* es un _read_ seguido de un _write_.

Podr√≠a pasar que se ejecuten en este orden:

 Acceso A                   Acceso B
 --------                   --------

 read (saldo)
 saldo = saldo + 1000
                            read (saldo)
                            saldo = saldo + 2000
 write(saldo)
                            write(saldo)

¬øD√≥nde quedaron los 1000 del _Acceso_A_?

Esto se conoce como _lost_update_problem_.

* Acceso concurrente (2)

*access*‚Üí*read,*modify,*write*

Supongamos dos accesos simult√°neos:

Acceso A

 insert into alquiler select * from reserva where fecha = now()::date;
 delete from reserva where fecha = now()::date;

Acceso B

 select count(*) from reserva;
 select count(*) from alquiler;

¬øQu√© inconveniente podr√≠a ocurrir?

Observaci√≥n

 now()::date == current_date

* Acceso concurrente (2 - continuaci√≥n)

*access*‚Üí*read,*modify,*write*

Podr√≠a pasar que se ejecuten en este orden:

 Acceso A                          Acceso B
 --------                          --------

 insert into alquiler
   select * from reserva
   where fecha = now()::date;
                                   select count(*) from reserva;
                                   select count(*) from alquiler;
 delete from reserva
 where fecha = now()::date;

En _Acceso_B_ estamos contando dos veces las reservas del d√≠a. 

Esto se conoce como _incorrect_summary_problem_.

* Resistencia a fallas

Estamos procesando los alquileres y las reservas‚Ä¶

 insert into alquiler select * from reserva where fecha = current_date;
 delete from reserva where fecha = current_date;

pero Edenor nos corta la luz justo antes del `delete`!!! üòø

* Transacci√≥n

_Es_una_secuencia_de_operaciones_SQL_que_se_tratan_como_una_unidad_l√≥gica_

- Cada transacci√≥n se ejecuta aisladamente
- Todo √≥ nada: se ejecuta completamente, √≥ no se ejecuta nada

* Propiedades ACID

* Propiedades ACID

- Atomicity
- Consistency
- Isolation
- Durability

* Atomicity

*Todo*√≥*nada:* se ejecuta completamente, √≥ no se ejecuta nada

La transacci√≥n siempre termina en `commit` √≥ en `rollback`

- `commit` ‚Üí la transacci√≥n se complet√≥ exitosamente

- `rollback` ‚Üí undo de una transacci√≥n parcial
__
__
_Asegurar_esta_propiedad_es_responsabilidad_del_DBMS_.

* Consistency

Una transacci√≥n *nunca* deja a la base de datos en un estado *inconsistente*

- Cuando una transacci√≥n comienza, la base de datos est√° en un estado consistente

- Cuando una transacci√≥n termina, se garantiza que la base de datos est√° en un estado consistente
__
__
_Es_responsabilidad_del_programador_de_la_transacci√≥n,_y_tambi√©n_del_DBMS_(por_las_constraints)_.

* Isolation

- Cada transacci√≥n *no* v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan concurrentemente
- Los resultados de una transacci√≥n deben ser los mismos que la ejecuci√≥n secuencial de las operaciones

_Serializaci√≥n:_ Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ orden secuencial de todas las transacciones 
__
__
_Asegurar_la_propiedad_Isolation_es_responsabilidad_del_DBMS_.

* Ejemplo de serializaci√≥n

T1

 update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;

T2

 update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;

‚úÖ  T1, T2 

‚úÖ  T2, T1 

* Durability

Todas operaciones sobre la base de datos *no*deben* cambiar despu√©s de que se complet√≥ exitosamente la transacci√≥n
__
__
_¬°Tambi√©n_es_responsabilidad_del_DBMS!_

* Isolation Levels

* Isolation

- Cada transacci√≥n *no* v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan *concurrentemente*
- Los resultados de una transacci√≥n *deben*ser*los*mismos* que la ejecuci√≥n secuencial de las operaciones

_Serializaci√≥n:_ Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ *orden*secuencial* de todas las transacciones 

‚úÖ  T1, T2, T3, T7, T10, T8, T9, T6, T4, T5

*Observaci√≥n:*es*v√°lido*s√≥lo*para*serializable*

* Isolation Levels (por transacci√≥n)

Weaker to Stronger:
1. `read`uncommitted`
2. `read`committed`
3. `repeatable`read`

‚ûñ Overhead
‚ûï Concurrency
‚ûñ Consistencia

Default:
4. `serializable`

‚ûï Overhead
‚ûñ Concurrency

* Dirty Read

Cuando una transacci√≥n lee un valor escrito por una transacci√≥n `uncommitted`

T1

 -- saldo ‚Üí 10000
 begin;
 update caja_de_ahorro set saldo = saldo + 5000 where n√∫mero_de_cuenta = 626;
 -- saldo ‚Üí 15000
 -- ac√° podemos tener un rollback
 commit;

T2 (`read`uncommitted`)

 begin;
 ‚Ä¶
 select saldo from caja_de_ahorro where n√∫mero_de_cuenta = 626;
 commit;

* read uncommitted

La transacci√≥n puede tener valores dirty reads

 begin;
 set transaction isolation level read uncommitted;
 /* operaciones */
 commit;

* read committed

La transacci√≥n *no* puede tener valores dirty reads _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 update cambio set compra = 25.75 where moneda = 'Dolar';
 commit;

T2

 begin;
 set transaction isolation level read committed;
 select max(compra) from cambio where moneda = 'Dolar';
 ‚Ä¶
 select max(compra) from cambio where moneda = 'Dolar';
 commit;

* repeatable read

- La transacci√≥n *no* puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 update cambio set compra = 25.75 where moneda = 'Dolar';
 update cambio set venta = 25.95 where moneda = 'Dolar';
 commit;

T2

 begin;
 set transaction isolation level repeatable read;
 select avg(compra) from cambio;
 select avg(venta) from cambio;
 commit;

* repeatable read (phantom tuples)

- La transacci√≥n *no* puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 insert into cambio ["compra y venta para varias monedas"];
 commit;

T2

 begin;
 set transaction isolation level repeatable read;
 select * from cambio;
 select avg(compra) from cambio;
 select max(compra) from cambio;
 commit;

* Resumiendo...

¬øQu√© problemas permite cada _isolation_level_?

 Isolation level  | Dirty Read | Unreap Read | Phamtom Read
 -----------------+------------+-------------+--------------
 read uncommitted |     SI     |      SI     |      SI
 read committed   |     NO     |      SI     |      SI
 repeatable read  |     NO     |      NO     |      SI
 serializable     |     NO     |      NO     |      NO

* read only

 begin;
 set transaction read only;
 select * from materia;
 select avg(nota) from materia_aprobada where legajo = 626;
 select nombre, apellido from alumno order by apellido;
 commit;

* Bibliograf√≠a

Elmasri and Navathe, _Fundamentals_of_database_systems_

- Cap√≠tulo 20, secciones 20.1, 20.3 y 20.6

# empty title
* 

.image img/questions.png
