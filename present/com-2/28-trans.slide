Transacciones

Hern√°n Rondelli
lucifer.unix.cabj@gmail.com

Daniel Bertaccini
dbertacc@campus.ungs.edu.ar

* db1-ungs.github.io/clases/com-2/trans.html

.image img/db1-ungs.github.io-clases-com-2-trans.html.png 500 _

* Transacciones ‚Äì ¬øPara qu√© sirven?

* Transacciones ‚Äì ¬øPara qu√© sirven?

- Acceso concurrente a los datos
- Resistencia a fallas

* Acceso concurrente (1)

*access*‚Üí*read,*modify,*write*

Supongamos dos modificaciones simult√°neas:

Acceso A

 update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;

Acceso B

 update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;

Si el cliente ten√≠a $10000 en su cuenta, ¬øcu√°nto dinero tiene ahora?

* Acceso concurrente (1 - continuaci√≥n)

*access*‚Üí*read,*modify,*write*

El *update* es un _read_ seguido de un _write_.

Podr√≠a pasar que se ejecuten en este orden:

 Acceso A                   Acceso B
 --------                   --------

 read (saldo)
 saldo = saldo + 1000
                            read (saldo)
                            saldo = saldo + 2000
 write(saldo)
                            write(saldo)

¬øD√≥nde quedaron los 1000 del _Acceso_A_?

Esto se conoce como _lost_update_problem_.

* Acceso concurrente (2)

*access*‚Üí*read,*modify,*write*

Supongamos dos accesos simult√°neos:

Acceso A

 insert into alquiler select * from reserva where fecha = now()::date;
 delete from reserva where fecha = now()::date;

Acceso B

 select count(*) from reserva;
 select count(*) from alquiler;

¬øQu√© inconveniente podr√≠a ocurrir?

Observaci√≥n

 now()::date == current_date

* Acceso concurrente (2 - continuaci√≥n)

*access*‚Üí*read,*modify,*write*

Podr√≠a pasar que se ejecuten en este orden:

 Acceso A                          Acceso B
 --------                          --------

 insert into alquiler
   select * from reserva
   where fecha = now()::date;
                                   select count(*) from reserva;
                                   select count(*) from alquiler;
 delete from reserva
 where fecha = now()::date;

En _Acceso_B_ estamos contando dos veces las reservas del d√≠a. 

Esto se conoce como _incorrect_summary_problem_.

* Resistencia a fallas

Estamos procesando los alquileres y las reservas‚Ä¶

 insert into alquiler select * from reserva where fecha = current_date;
 delete from reserva where fecha = current_date;

pero Edenor nos corta la luz justo antes del `delete`!!! üòø

* Transacci√≥n

_Es_una_secuencia_de_operaciones_SQL_que_se_tratan_como_una_unidad_l√≥gica_

- Cada transacci√≥n se ejecuta aisladamente
- Todo √≥ nada: se ejecuta completamente, √≥ no se ejecuta nada

* Propiedades ACID

* Propiedades ACID

- Atomicity
- Consistency
- Isolation
- Durability

* Atomicity

*Todo*√≥*nada:* se ejecuta completamente, √≥ no se ejecuta nada

La transacci√≥n siempre termina en `commit` √≥ en `rollback`

- `commit` ‚Üí la transacci√≥n se complet√≥ exitosamente

- `rollback` ‚Üí undo de una transacci√≥n parcial
__
__
_Asegurar_esta_propiedad_es_responsabilidad_del_DBMS_.

* Consistency

Una transacci√≥n *nunca* deja a la base de datos en un estado *inconsistente*

- Cuando una transacci√≥n comienza, la base de datos est√° en un estado consistente

- Cuando una transacci√≥n termina, se garantiza que la base de datos est√° en un estado consistente
__
__
_Es_responsabilidad_del_programador_de_la_transacci√≥n,_y_tambi√©n_del_DBMS_(por_las_constraints)_.

* Isolation

- Cada transacci√≥n *no* v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan concurrentemente
- Los resultados de una transacci√≥n deben ser los mismos que la ejecuci√≥n secuencial de las operaciones

_Serializaci√≥n:_ Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ orden secuencial de todas las transacciones 
__
__
_Asegurar_la_propiedad_Isolation_es_responsabilidad_del_DBMS_.

* Ejemplo de serializaci√≥n

T1

 update caja_de_ahorro set saldo = saldo + 1000 where n√∫mero_de_cuenta = 626;

T2

 update caja_de_ahorro set saldo = saldo + 2000 where n√∫mero_de_cuenta = 626;

‚úÖ  T1, T2 

‚úÖ  T2, T1 

* Durability

Todas operaciones sobre la base de datos *no*deben* cambiar despu√©s de que se complet√≥ exitosamente la transacci√≥n
__
__
_¬°Tambi√©n_es_responsabilidad_del_DBMS!_

* Isolation Levels

* Isolation

- Cada transacci√≥n *no* v√© lo que otra transacci√≥n est√° haciendo
- Las transacciones se procesan *concurrentemente*
- Los resultados de una transacci√≥n *deben*ser*los*mismos* que la ejecuci√≥n secuencial de las operaciones

_Serializaci√≥n:_ Las operaciones se pueden entrelazar pero la ejecuci√≥n debe ser equivalente a _alg√∫n_ *orden*secuencial* de todas las transacciones 

‚úÖ  T1, T2, T3, T7, T10, T8, T9, T6, T4, T5

*Observaci√≥n:*es*v√°lido*s√≥lo*para*serializable*

* Isolation Levels (por transacci√≥n)

De m√°s d√©bil a m√°s fuerte:

1. `read`uncommitted`
2. `read`committed`
3. `repeatable`read`

‚ûñ Overhead
‚ûï Concurrencia
‚ûñ Consistencia


4. `serializable`

‚ûï Overhead
‚ûñ Concurrencia

* Problema: Dirty Read

Cuando una transacci√≥n lee un valor escrito por una transacci√≥n `uncommitted`

T1

 -- saldo ‚Üí 10000
 begin;
 update caja_de_ahorro set saldo = saldo + 5000 where n√∫mero_de_cuenta = 626;
 -- saldo ‚Üí 15000
 -- ac√° podemos tener un rollback
 commit;

T2 (`read`uncommitted`)

 begin;
 ‚Ä¶
 select saldo from caja_de_ahorro where n√∫mero_de_cuenta = 626;
 commit;

* read uncommitted

La transacci√≥n puede tener valores dirty reads

 begin;
 set transaction isolation level read uncommitted;
 /* operaciones */
 commit;

* read committed

La transacci√≥n *no* puede tener valores dirty reads _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 update caja_de_ahorro set saldo = saldo + 5000 where n√∫mero_de_cuenta = 626;
 ‚Ä¶
 commit;

T2

 begin;
 set transaction isolation level read committed; -- evita dirty reads
 select saldo from caja_de_ahorro where n√∫mero_de_cuenta = 626;
 commit;

* Problema: Nonrepeatable Read

Cuando una transacci√≥n lee dos veces el mismo valor, la segunda lectura puede ser diferente (si fue modificado por otra transacci√≥n)

T1

 begin;
 update cambio set venta = 1040.00 where moneda = 'Dolar' and fecha = now()::date;
 update cambio set venta = 1080.00 where moneda = 'Dolar' and fecha = now()::date;
 commit;

T2

 begin;
 select venta from cambio where moneda = 'Dolar' and fecha = now()::date;
 ‚Ä¶
 select venta from cambio where moneda = 'Dolar' and fecha = now()::date;
 commit;

* repeatable read

- La transacci√≥n *no* puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- _(todav√≠a_no_garantiza_serializaci√≥n)_

T1

 begin;
 update cambio set venta = 1040.00 where moneda = 'Dolar' and fecha = now()::date;
 update cambio set venta = 1080.00 where moneda = 'Dolar' and fecha = now()::date;
 commit;

T2

 begin;
 set transaction isolation level repeatable read; -- evita nonreapeatable reads
 select venta from cambio where moneda = 'Dolar' and fecha = now()::date;
 ‚Ä¶
 select venta from cambio where moneda = 'Dolar' and fecha = now()::date;
 commit;

* Problema: Phantom Tuples

Cuando una transacci√≥n lee dos veces una misma tabla, la segunda lectura puede recuperar nuevas filas (si fueron insertadas por otra transacci√≥n)

T1

 begin;
 insert into cambio values ('2024-05-09','Dolar',1025.00,1045.00);
 insert into cambio values ('2024-05-10','Dolar',1020.00,1040.00);
 commit;

T2

 begin;
 select * from cambio where moneda = 'Dolar';
 ‚Ä¶
 select * from cambio where moneda = 'Dolar';
 commit;

* serializable

- La transacci√≥n *no* puede tener valores dirty reads
- Un valor le√≠do m√°s de una vez, no puede cambiar
- No pueden aparecer _phantom_tuples_ en segundas lecturas

T1

 begin;
 insert into cambio values ('2024-05-09','Dolar',1025.00,1045.00);
 insert into cambio values ('2024-05-10','Dolar',1020.00,1040.00);
 commit;

T2

 begin;
 set transaction isolation level serializable; -- evita phantom tuples
 select * from cambio where moneda = 'Dolar';
 ‚Ä¶
 select * from cambio where moneda = 'Dolar';
 commit;

* Resumiendo...

¬øQu√© problemas permite cada _isolation_level_?

 Isolation level  | Dirty Read | Nonreap Read | Phamtom Tuples
 -----------------+------------+--------------+---------------
 read uncommitted |     SI     |      SI      |       SI
 read committed   |     NO     |      SI      |       SI
 repeatable read  |     NO     |      NO      |       SI
 serializable     |     NO     |      NO      |       NO

* read only

 begin;
 set transaction read only;
 select * from materia;
 select avg(nota) from materia_aprobada where legajo = 626;
 select nombre, apellido from alumno order by apellido;
 commit;

* Bibliograf√≠a

Elmasri and Navathe, _Fundamentals_of_database_systems_

- Cap√≠tulo 20, secciones 20.1, 20.3 y 20.6

# empty title
* 

.image img/questions.png
